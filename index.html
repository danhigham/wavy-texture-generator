<!DOCTYPE html>
<html lang="en">
<head>
    <title>Three.js Interactive Waves</title>
    <meta charset="utf-8">
    <style>
        body { margin: 0; background-color: #111; }
        canvas { display: block; }
        
        .button-container {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
            display: flex;
            align-items: center;
        }
        
        .button-container button {
            padding: 10px 15px;
            font-family: Arial, sans-serif;
            font-size: 16px;
            background-color: #0077ff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-right: 10px;
        }
        .button-container button:hover {
            background-color: #0055cc;
        }

        #fileSizeIndicator {
            font-family: Arial, sans-serif;
            font-size: 14px;
            color: #ffffff;
            margin-left: 10px;
            /* 3. Add a minimum width to prevent UI jitter */
            min-width: 150px; 
        }
        
        .lil-gui {
            z-index: 101 !important; 
        }
    </style>
</head>
<body>
    <div class="button-container">
        <button id="exportButton">Export as STL</button>
        <button id="regenButton">Regenerate</button>
        <span id="fileSizeIndicator"></span>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/",
                "simplex-noise": "https://cdn.skypack.dev/simplex-noise",
                "lil-gui": "https://unpkg.com/lil-gui@0.19.1/dist/lil-gui.esm.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { STLExporter } from 'three/addons/exporters/STLExporter.js';
        import { createNoise2D } from 'simplex-noise';
        import { GUI } from 'lil-gui';

        let scene, camera, renderer, controls;
        let rippledGeometry, solidMesh;
        const noise2D = createNoise2D();
        
        // 1. Add a debounce timer variable
        let debounceTimer;

        const fileSizeIndicator = document.getElementById('fileSizeIndicator');
        const exporter = new STLExporter(); // 4. Init exporter once

        const params = {
            AMPLITUDE: 0.8,
            WAVE_FREQUENCY: 0.5,
            UNDULATION_FREQUENCY: 0.1,
            UNDULATION_STRENGTH: 3.0,
            THICKNESS_VARIATION_FREQ: 0.2,
            BOX_WIDTH: 10,
            BOX_HEIGHT: 1,
            BOX_DEPTH: 10,
            WIDTH_SEGMENTS: 5,
            DEPTH_SEGMENTS: 5,
            SEED_X: 0, 
            SEED_Z: 0
        };

        init();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222222);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(8, 8, 8);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            
            const ambientLight = new THREE.AmbientLight(0x404040, 1);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 2);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);

            rippledGeometry = createRippledBox();

            const material = new THREE.MeshStandardMaterial({ 
                color: 0x0077ff,
                roughness: 1.3
            });
            solidMesh = new THREE.Mesh(rippledGeometry, material);
            scene.add(solidMesh);

            const gui = new GUI();
            
            const dimFolder = gui.addFolder('Dimensions');
            dimFolder.add(params, 'BOX_WIDTH', 1, 2000).name('Width').onChange(regenerateMesh);
            dimFolder.add(params, 'BOX_HEIGHT', 1, 10).name('Height').onChange(regenerateMesh);
            dimFolder.add(params, 'BOX_DEPTH', 1, 2000).name('Depth').onChange(regenerateMesh);

            const resFolder = gui.addFolder('Resolution');
            resFolder.add(params, 'WIDTH_SEGMENTS', 1, 50, 1).name('Width Segments').onChange(regenerateMesh);
            resFolder.add(params, 'DEPTH_SEGMENTS', 1, 50, 1).name('Depth Segments').onChange(regenerateMesh);
            
            const waveFolder = gui.addFolder('Waves');
            waveFolder.add(params, 'AMPLITUDE', 0.1, 2.0).name('Base Amplitude').onChange(regenerateMesh);
            waveFolder.add(params, 'THICKNESS_VARIATION_FREQ', 0.01, 1.0).name('Thickness Freq.').onChange(regenerateMesh);
            waveFolder.add(params, 'WAVE_FREQUENCY', 0.1, 2.0).name('Wave Frequency').onChange(regenerateMesh);
            waveFolder.add(params, 'UNDULATION_FREQUENCY', 0.01, 0.5).name('Undulation Freq.').onChange(regenerateMesh);
            waveFolder.add(params, 'UNDULATION_STRENGTH', 0.0, 10.0).name('Undulation Str.').onChange(regenerateMesh);

            window.addEventListener('resize', onWindowResize, false);
            document.getElementById('exportButton').addEventListener('click', exportSTL);
            
            document.getElementById('regenButton').addEventListener('click', randomizeSeed);
            
            // 2. Show initial file size on load
            updateFileSizePreview();
            
            animate();
        }

        function randomizeSeed() {
            params.SEED_X = Math.random() * 1000;
            params.SEED_Z = Math.random() * 1000;
            
            // 6. This now handles the debounced update automatically
            regenerateMesh();
        }

        // 3. This function is now the trigger for the debounced update
        function regenerateMesh() {
            const newGeometry = createRippledBox();
            rippledGeometry.dispose();
            rippledGeometry = newGeometry;
            solidMesh.geometry = rippledGeometry;

            // --- Debounced File Size Update Logic ---
            clearTimeout(debounceTimer);
            if(fileSizeIndicator) fileSizeIndicator.textContent = 'Calculating size...';
            
            // Set a new timer to run the update function after 300ms
            debounceTimer = setTimeout(updateFileSizePreview, 300); 
        }
        
        // 4. New function to calculate and display the file size
        function updateFileSizePreview() {
            // Generate the STL string in memory
            const stlString = exporter.parse(solidMesh, { binary: false });
            // Create a blob to accurately get the size
            const blob = new Blob([stlString], { type: 'text/plain' });
            const fileSize = blob.size;

            if(fileSizeIndicator) {
                fileSizeIndicator.textContent = `Est. Size: ${formatBytes(fileSize)}`;
            }
        }

        function formatBytes(bytes, decimals = 2) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const dm = decimals < 0 ? 0 : decimals;
            const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
        }

        // 5. ExportSTL is now simpler
        function exportSTL() {
            const stlString = exporter.parse(solidMesh, { binary: false });
            const blob = new Blob([stlString], { type: 'text/plain' });

            // The file size is already visible, so we just create the link
            const link = document.createElement('a');
            link.style.display = 'none';
            document.body.appendChild(link);
            link.href = URL.createObjectURL(blob);
            link.download = 'rippled_cuboid.stl';
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(link.href);
        }

        function createRippledBox() {
            const geometry = new THREE.BoxGeometry(
                params.BOX_WIDTH, 
                params.BOX_HEIGHT, 
                params.BOX_DEPTH,
                (params.WIDTH_SEGMENTS * params.BOX_WIDTH) / 2.5,
                1, 
                (params.DEPTH_SEGMENTS * params.BOX_DEPTH) / 2.5
            );

            // console.log(params.DEPTH_SEGMENTS * params.BOX_DEPTH); // This log is still here

            const positionAttribute = geometry.attributes.position;
            const originalY = params.BOX_HEIGHT / 2.0;

            for (let i = 0; i < positionAttribute.count; i++) {
                const y = positionAttribute.getY(i);

                if (Math.abs(y - originalY) < 0.001) {
                    const x = positionAttribute.getX(i);
                    const z = positionAttribute.getZ(i);

                    const amplitudeMultiplier = (noise2D(
                        x * params.THICKNESS_VARIATION_FREQ + params.SEED_X, 
                        z * params.THICKNESS_VARIATION_FREQ + params.SEED_Z
                    ) + 1) * 0.5; 
                    
                    const finalAmplitude = params.AMPLITUDE * (0.2 + amplitudeMultiplier * 0.8);
                    
                    const undulation = noise2D(
                        x * params.UNDULATION_FREQUENCY + params.SEED_X, 
                        z * params.UNDULATION_FREQUENCY + params.SEED_Z
                    ) * params.UNDULATION_STRENGTH;
                    
                    const mainWaveX = x + undulation;
                    const noiseVal = noise2D(
                        mainWaveX * params.WAVE_FREQUENCY + params.SEED_X, 
                        0.0 + params.SEED_Z 
                    );
                    
                    const offset = finalAmplitude * noiseVal;
                    
                    positionAttribute.setY(i, y + offset);
                }
            }

            positionAttribute.needsUpdate = true;
            geometry.computeVertexNormals();

            return geometry;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>